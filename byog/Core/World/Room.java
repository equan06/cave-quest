package byog.Core.World;

import byog.Core.RandomUtils;
import byog.TileEngine.TETile;
import byog.TileEngine.Tileset;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Random;

public class Room implements Serializable {

    private static final long serialVersionUID = 1111111111114L;
    protected final Position pos;
    protected final Position maxpos;
    protected final Position centerpos;
    protected final int base;
    protected final int height;
    private final Random random;
    protected TETile floor = Tileset.FLOOR;
    private int idnum = 0;
    private static int idcount = 0;
    private boolean occupied = false;

    public Room(Position p, int b, int h, TETile f, Random r) {
        pos = p;
        base = b;
        height = h;
        maxpos = new Position(pos.getX() + base, pos.getY() + height);
        centerpos = new Position(pos.getX() + base / 2, pos.getY() + height / 2);
        floor = f;
        random = r;
    }

    public Room(Position p, int b, int h, Random r) {
        pos = p;
        base = b;
        height = h;
        maxpos = new Position(pos.getX() + base, pos.getY() + height);
        centerpos = new Position(pos.getX() + base / 2, pos.getY() + height / 2);
        random = r;
    }

    /** Creates a room of random size no smaller than 2x2 and
     * no larger than 10x10 (each room should have at least 2x2
     * floor tiles!). Height and Width is uniformly generated.
     * @param p Position object containing x,y coord
     * @param r Random object generated by SEED in class Game */
    public Room(Position p, Random r) {
        pos = p;
        base = RandomUtils.uniform(r, 2, 10);
        height = RandomUtils.uniform(r, 2, 10);
        maxpos = new Position(pos.getX() + base, pos.getY() + height);
        centerpos = new Position(pos.getX() + base / 2, pos.getY() + height / 2);
        random = r;
    }

    public TETile getFloor() {
        return floor;
    }

    public Random getRandom() {
        return random;
    }

    public Position getPos() {
        return pos;
    }

    public Position getCenterpos() {
        return centerpos;
    }

    public Position getMaxpos() {
        return maxpos;
    }

    public boolean isOccupied() {
        return occupied;
    }

    public void setOccupied() {
        occupied = true;
    }
    /**Draws the room's FLOOR tiles on the world array.
     * Rooms are drawn by floors first, then by adding walls
     * after all rooms and corridors are drawn.
     * @param world the world array */
    public void draw(TETile[][] world) {
        for (int i = 0; i < base; i++) {
            for (int j = 0; j < height; j++) {
                world[pos.getX() + i][pos.getY() + j] = floor;
            }
        }
        this.assignID();
    }

    /** Assigns a unique ID number to each unique room.
     *  Corridor also has unique ID values, but they are not
     *  used. */
    public void assignID() {
        idnum = Room.idcount;
        idcount++;
    }

    /**
     * ID num is used to index the rooms in an adjacency matrix.
     * For example, the 1st room in the matrix has index 1.
     * @return unique id integer */
    public int getID() {
        return idnum;
    }

    public static void resetIDCount() {
        idcount = 0;
    }

    /**
     * Return true if room1 (current obj) overlaps room 2.
     * @source user Charles Bretana on stackoverflow for
     * simplified comparison technique. Uses DeMorgan's law
     * to simplify conditions of non-overlapping rectangles.
     * https://stackoverflow.com/questions/306316/determine-if-two-rectangles-overlap-each-other
     *
     * Additionally, ensures that rooms are generated at least 3 tiles away from each other, since
     * only the floors of rooms are generated.
     * @param room2 the room to compare to
     * @return true if overlapping
     * */
    public boolean overlaps(Room room2) {
        return (maxpos.getX() + 4 > room2.pos.getX() && maxpos.getY() + 4 > room2.pos.getY()
                && room2.maxpos.getY() + 4 > pos.getY() && room2.maxpos.getX() + 4 > pos.getX());
    }


    /**Connects current room with Room 2 by drawing a corridor between them,
     * and adds both rooms to the adjacency matrix. Does not connect rooms
     * that are already directly connected, but it is possible to indirectly
     * connect more than once if a corridor overlaps a connection to another room.
     *
     * Corridors are drawn by taking the distance between the centers
     * of two rooms and then calculating the x and y components.
     *
     * @param mat adjacency matrix containing graph connections
     * @param room2 the room to be connected to
     * @param world the world to be drawn in
     */
    public void connectTo(AdjMatrix mat, Room room2, TETile[][] world) {
        if (room2 == null || mat.checkConnected(this, room2)) {
            return;
        }
        int dx = room2.centerpos.getX() - centerpos.getX();
        int dy = room2.centerpos.getY() - centerpos.getY();

        Corridor vert = new Corridor(centerpos, 1, dy, random);
        Position hpos = new Position(centerpos.getX(), centerpos.getY() + dy);
        Corridor horz = new Corridor(hpos, dx, 1, random);

        if (dx == 0) {
            vert.draw(world);
        } else if (dy == 0) {
            horz.draw(world);
        } else {
            vert.draw(world);
            horz.draw(world);
        }

        mat.addRooms(this, room2);
    }

    /** Take a list of rooms and find the closest room based on
     * center positions. If more than one are closest, return the
     * last closest one.
     * @param rooms the list of rooms
     * @return the closest room in rooms */
    public Room findClosest(ArrayList<Room> rooms) {
        int min = 0;
        Room closest = null;
        for (Room r : rooms) {
            if (!this.equals(r)) {
                int dist = centerpos.diff(r.centerpos);
                if (min == 0) {
                    min = dist;
                    closest = r;
                } else if (dist < min) {
                    min = dist;
                    closest = r;
                }
            }
        }
        return closest;
    }

    public Room findRandom(ArrayList<Room> rooms) {
        Room room2 = null;
        while (room2 == null || room2.equals(this)) {
            room2 = rooms.get(RandomUtils.uniform(random, 0, rooms.size()));
        }
        return room2;
    }

    public String toString() {
        return "Room " + idnum;

    }


    /**
     * Returns true if room is 2x2 or smaller. Portal room
     * should spawn in room 3x3 or larger.
     * */
    public boolean isPortalSpawnInvalid() {
        return (base < 3 || height < 3);
    }

}
